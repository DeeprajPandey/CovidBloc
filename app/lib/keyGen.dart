// A Dart port of the Exposure Notification API. The class has
// a custom implementation of all the functionalities of the API.
//
// 2020. Ashoka University Computer Science.

import 'dart:async';
import 'dart:convert' show utf8;
import "dart:typed_data";

import 'package:convert/convert.dart';
import 'package:cryptography/cryptography.dart';

class ExposureNotification {
  /// Calculate and return the index of the 10-min interval during
  /// a day that the given time lies in.
  ///
  /// ENIntervalNumber in Docs.
  ///
  /// @param timestamp  the current time of which we need the interval number
  /// @return      the 10-min interval index (0-143)
  int getIntervalNumber({DateTime timestamp}) {
    var lastMidnight =
        new DateTime(timestamp.year, timestamp.month, timestamp.day);

    // Get the Unix time for that day's midnight and current time
    var currentUnix =
        ((timestamp.toUtc().millisecondsSinceEpoch) / 1000).floor();
    var lastMidnightUnix =
        ((lastMidnight.toUtc().millisecondsSinceEpoch) / 1000).floor();

    // This is how long it has been since the day started
    var diff = currentUnix - lastMidnightUnix;

    // Calculate the current 10-min interval number in the day
    return (diff / 600).floor();
  }

  /// Generate the daily key every day at 00:00 that generates
  /// that day's keys. Called temporary exposure key in Doc.
  ///
  /// TemporaryExposureKey in Docs.
  ///
  /// @return       16-byte cryptographically secure key
  SecretKey temporaryExpKeygen() {
    return SecretKey.randomBytes(16);
  }

  /// Generate the secodary set of keys for the final encryption.
  /// 
  /// This utility function can be used to generate the rolling
  /// proximity identifier key and the associated encrypted metadata
  /// key.
  /// 
  /// @param  dailyKey    that day's temporary exposure key
  ///         stringData  string that will be encoded during keygen
  ///                     (either EN-RPI or CT-AEMK)
  /// @return key         generated RPI or AEM key
  Future<SecretKey> secondaryKeygen(SecretKey dailyKey,
      {String stringData}) async {
    var encodedData = utf8.encode(stringData);
    var hkdf = Hkdf(Hmac(sha256));
    var key = await hkdf.deriveKey(dailyKey,
        nonce: null, info: encodedData, outputLength: 16);
    return key;
  }

  /// Return the ByteData (List<int>) representation of an integer.
  /// 
  /// @param  val         number to be represented in bytes
  /// @return Uint8List   number in byte form
  Uint8List intToBytes(int val) =>
      Uint8List(4)..buffer.asByteData().setInt32(0, val, Endian.little);
  
  /// Generate the Rolling Proximity Identifier given the RPI Key.
  /// 
  /// Called every 10 minutes.
  /// 
  /// @param  rpiKey  RPI Key generated by secondaryKeygen()
  /// @return rpi     hex encoding of the rolling proximity ID
  Future<String> rollingProximityID(SecretKey rpiKey) async {
    // Create a mutable list to store PaddedData
    List<int> paddedData = new List.generate(6, (index) => 0, growable: true);
    // PaddedData starts with the bytes for thisstring
    List.copyRange(paddedData, 0, utf8.encode('EN-RPI')); // [0,5]
    
    // add 0's from [6, 15], we will leave the 0's from 6-11 for interval id
    for (var i = 0; i < 10; i++) {
      paddedData.add(0);
    }

    // Get the current interval number (b/w 0-143)
    var j = new DateTime.now();
    var eNIntervalNumber =
        getIntervalNumber(timestamp: j);
    print('Current interval number: $eNIntervalNumber');
    // Add the little endian representation of ENINT to the end of RPI
    List.copyRange(paddedData, 12, intToBytes(eNIntervalNumber));

    // Nonce is required by the lib function, we will concat rpi to this
    var nonce = aesGcm.newNonce();
    final rollingProximityIdentifier =
        await aesGcm.encrypt(paddedData, secretKey: rpiKey, nonce: nonce);
    // TODO: concat nonce to beginning of RPI

    // print('RPI Bytes: $rollingProximityIdentifier');
    // print('RPI Bytes: ${hex.decode(hex.encode(rollingProximityIdentifier))}');
    print('RPI Hex: ${hex.encode(rollingProximityIdentifier)}');
    
    return hex.encode(rollingProximityIdentifier);
  }

  /// The driver/scheduler function
  Future<void> scheduler() async {
    SecretKey tempKey = temporaryExpKeygen();
    // print('Daily Key: ${hex.encode(await tempKey.extract())}');
    var rpiKey = await secondaryKeygen(tempKey, stringData: 'EN-RPIK');
    // print('RPI Key: ${hex.encode(await rpiKey.extract())}');

    print(await rollingProximityID(rpiKey));

    var aemKey = await secondaryKeygen(tempKey, stringData: 'CT-AEMK');
    // print('AEM Key: ${hex.encode(await aemKey.extract())}');
  }
}

// Using only for debug
void main() async {
  ExposureNotification exp = new ExposureNotification();
  await exp.scheduler();
}
